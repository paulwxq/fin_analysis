# refinement_llm 模块概要设计文档

## 1. 模块概述

### 1.1 模块定位
refinement_llm 模块是量化选股工具链中的精细化筛选环节，基于多模态 LLM 的视觉识别能力，对初筛后的股票月K线图进行形态分析和评分，精准识别"曾经大涨 → 大幅回撤 → 近2~3年横盘起伏不大"的平底锅形态股票。

### 1.2 核心价值
- **视觉智能**：利用多模态LLM突破传统量化的数字限制，捕捉视觉形态特征
- **专家经验沉淀**：通过Prompt Engineering将资深技术分析师的"盘感"固化为AI能力
- **精准筛选**：在初筛基础上进一步降低假阳性，提高选股质量

### 1.3 技术栈
- **Python**: 3.12.x
- **虚拟环境管理**: uv
- **LLM框架**: MS Agent-Framework python-1.0.0b260127
- **数据库**: PostgreSQL
- **日志**: Python logging
- **LLM提供商**: 阿里云灵积（DashScope）/ OpenAI / DeepSeek (通过 OpenAI 兼容接口)

---

## 2. 系统架构

### 2.1 模块结构
```
refinement_llm/
├── __init__.py              # 模块入口
├── config.py                # 配置管理
├── main.py                  # 主流程控制
├── image_loader.py          # 图像加载器
├── llm_analyzer.py          # LLM分析器 (Async)
├── db_handler.py            # 数据库处理器
├── logger.py                # 日志管理器
├── models.py                # 数据模型定义
└── prompts.py               # Prompt模板管理
```

### 2.2 分层架构
```
┌─────────────────────────────────────────┐
│          CLI Entry Layer                │
│         (main.py + argparse)            │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│        Business Logic Layer             │
│  (Orchestration & Workflow Control)     │
│       (Async Event Loop)                │
└─────────────────────────────────────────┘
              ↓
┌───────────────┬──────────────┬──────────┐
│ Image Loader  │ LLM Analyzer │ DB Handler│
└───────────────┴──────────────┴──────────┘
              ↓
┌─────────────────────────────────────────┐
│       Infrastructure Layer              │
│   (Logging, Config, Agent Framework)    │
└─────────────────────────────────────────┘
```

---

## 3. 核心功能模块设计

### 3.1 配置管理模块 (config.py)

#### 3.1.1 配置项定义
```python
class RefinementConfig:
    # LLM配置
    # 推荐通过环境变量配置 OPENAI_API_KEY, OPENAI_BASE_URL, OPENAI_MODEL
    DEFAULT_MODEL: str = "qwen-plus" 
    
    # 图像路径配置
    # 注意：需确保生成的K线图包含MA30指标，路径指向项目根目录下的 output 文件夹
    DEFAULT_IMAGE_DIR: str = "./output"
    IMAGE_PATTERN: str = "*_kline.png"

    # 数据库配置
    DB_TABLE: str = "public.stock_flatbottom_refinement"

    # 日志配置
    LOG_DIR: str = "./logs"
    LOG_FILE: str = "refinement_llm.log"
    CONSOLE_LOG_LEVEL: str = "INFO"
    FILE_LOG_LEVEL: str = "DEBUG"

    # 评分阈值
    SCORE_THRESHOLD: float = 6.0
```

#### 3.1.2 环境变量读取
从 `.env` 文件加载：
- `DASHSCOPE_API_KEY` (或 `OPENAI_API_KEY`)
- `DASHSCOPE_BASE_URL` (或 `OPENAI_BASE_URL`)
- `DATABASE_URL`

### 3.2 图像加载模块 (image_loader.py)

#### 3.2.1 功能职责
- 扫描指定目录下的 K线图文件
- 解析文件名提取股票代码
- 验证文件有效性
- 返回待处理的图像列表

#### 3.2.2 核心类设计
```python
class ImageLoader:
    def __init__(self, base_dir: str):
        """初始化图像加载器"""

    def scan_images(self) -> List[StockImage]:
        """扫描并返回所有K线图"""

    def extract_stock_code(self, filename: str) -> str:
        """从文件名提取股票代码（如 000876.SZ）"""

    def validate_image(self, filepath: str) -> bool:
        """验证图像文件是否有效"""
```

#### 3.2.3 数据模型
```python
@dataclass
class StockImage:
    stock_code: str      # 股票代码
    file_path: str       # 文件路径
    file_size: int       # 文件大小
    valid: bool          # 是否有效
```

### 3.3 LLM分析模块 (llm_analyzer.py)

#### 3.3.1 核心职责
- 封装 MS Agent-Framework 的 `ChatAgent` 与 `OpenAIChatClient`
- 异步处理图像分析请求
- 构造符合 MAF 规范的多模态消息 (`ChatMessage` + `DataContent`)
- 解析 LLM 返回结果
- 处理异常和重试

#### 3.3.2 核心类设计 (Async)
```python
class LLMAnalyzer:
    def __init__(self, model_name: str, api_key: str, base_url: str):
        """初始化LLM分析器，配置 ChatAgent"""
        # 初始化 Agent Framework 客户端

    async def analyze_kline(self, image_path: str, stock_code: str) -> AnalysisResult:
        """(Async) 分析单张K线图，返回评分结果"""

    async def batch_analyze(self, images: List[StockImage]) -> List[AnalysisResult]:
        """(Async) 批量分析多张图片，控制并发"""

    def parse_llm_response(self, response: str) -> Dict:
        """解析LLM返回的JSON结果"""
```

#### 3.3.3 返回数据模型
```python
@dataclass
class AnalysisResult:
    stock_code: str              # 股票代码
    score: float                 # 评分 (0-10)
    pattern_name: str            # 形态名称
    reasoning: str               # 评分原因
    stage: str                   # 威科夫阶段
    ma30_status: str             # 30月均线状态
    volume_pattern: str          # 量能形态
    analysis_timestamp: datetime # 分析时间
    image_path: str              # 分析的图片路径
    success: bool                # 是否成功
    error_message: Optional[str] # 错误信息
```

### 3.4 Prompt管理模块 (prompts.py)

#### 3.4.1 System Prompt设计
```python
SYSTEM_PROMPT = """你是一位拥有20年经验的华尔街技术分析师，精通威科夫操盘法（Wyckoff Method）和斯坦·温斯坦的阶段分析理论（Stage Analysis）。

你的任务是分析上传的A股月线K线图，判断该股票是否符合"长期超跌后的底部沉淀"（Stage 1 Base）形态。

**前提条件**：
- 请重点关注图表中的30月均线（或图中长期均线），这是判断阶段的关键指标。
- 图表标题或左上角通常包含股票代码，请在结果中确认该代码。

评分标准 (0-10分)：

1. **曾经辉煌与暴跌 (Left Side)**:
   - 图表左侧是否有明显的历史高点？
   - 是否经历了深幅下跌（跌幅>50%）？
   - 如果没有深幅下跌，得分≤4分

2. **底部结构 (Base Formation)**:
   - 右侧是否形成长期的、扁平的箱体？
   - 箱体持续时间是否≥12个月？
   - 横盘期间波动率是否显著降低？

3. **波动收敛 (Volatility Contraction)**:
   - 箱体内的K线实体是否越来越短？
   - 是否有上下影线刺探支撑但未破位的行为？

4. **均线行为 (Moving Average)**:
   - 股价是否站上或缠绕30月均线？
   - 30月均线是否由跌转平，甚至微幅上翘？

5. **量能行为 (Volume Pattern)**:
   - 下跌时是否缩量（地量）？
   - 箱体震荡期间是否有间歇性的放量阳线（吸筹信号）？

评分规则：
- 0-4分：仍在下跌趋势中，或仅是"下跌中继"形态
- 5-7分：基本符合底部特征，但形态不够标准（波动过大、时间太短）
- 8-10分：教科书般的"平底锅"形态，长期横盘且波动极小，蓄势待发

请严格按照以下JSON格式输出（不要添加额外的markdown标记）：
{
  "stock_code": "000xxx.SZ",
  "score": 8.5,
  "pattern_name": "Classic Pan Bottom",
  "reasoning": "该股经历了长达3年的深幅调整（跌幅超70%），在底部形成了为期24个月的横盘箱体，期间波动率显著收敛，近期股价已站上30月均线，均线开始走平上翘。量能方面，下跌阶段持续缩量，底部出现多次放量阳线，符合主力吸筹特征。",
  "stage": "Stage 1 Base",
  "ma30_status": "站上并上翘",
  "volume_pattern": "底部放量吸筹"
}
"""
```

#### 3.4.2 User Prompt设计
```python
def get_user_prompt(stock_code: str) -> str:
    return f"""请分析股票代码为 {stock_code} 的月K线图。

请验证图片中的股票代码是否为 {stock_code}，并按照系统提示中的评分标准进行详细分析。
请务必在返回的JSON中包含 'stock_code' 字段。"""
```

### 3.5 数据库处理模块 (db_handler.py)

#### 3.5.1 核心职责
- 管理数据库连接
- 清空目标表
- 批量写入分析结果
- 处理数据库异常

#### 3.5.2 表结构设计
```sql
CREATE TABLE IF NOT EXISTS public.stock_flatbottom_refinement (
    stock_code VARCHAR(20) PRIMARY KEY,          -- 股票代码
    score NUMERIC(4,2) NOT NULL,                 -- 评分 (0-10)
    pattern_name VARCHAR(100),                    -- 形态名称
    reasoning TEXT,                               -- 评分原因
    stage VARCHAR(50),                            -- 威科夫阶段
    ma30_status VARCHAR(50),                      -- 30月均线状态
    volume_pattern VARCHAR(100),                  -- 量能形态
    image_path VARCHAR(255),                      -- 分析的图片路径
    analysis_timestamp TIMESTAMP DEFAULT NOW(),   -- 分析时间
    create_time TIMESTAMP DEFAULT NOW(),          -- 创建时间
    update_time TIMESTAMP DEFAULT NOW()           -- 更新时间
);

CREATE INDEX IF NOT EXISTS idx_score ON public.stock_flatbottom_refinement(score DESC);
CREATE INDEX IF NOT EXISTS idx_pattern ON public.stock_flatbottom_refinement(pattern_name);
```

#### 3.5.3 核心类设计
```python
class DBHandler:
    def __init__(self, db_url: str):
        """初始化数据库连接"""

    def truncate_table(self) -> bool:
        """清空目标表"""

    def batch_insert(self, results: List[AnalysisResult]) -> int:
        """批量插入分析结果"""

    def get_top_stocks(self, limit: int = 50) -> List[Dict]:
        """获取评分最高的N只股票"""
```

### 3.6 日志管理模块 (logger.py)

#### 3.6.1 日志配置
```python
class LoggerConfig:
    def setup_logger(name: str) -> logging.Logger:
        """配置双输出日志（控制台 + 文件）"""
        # 控制台：INFO级别
        # 文件：DEBUG级别
```

---

## 4. 数据流程设计

### 4.1 主流程图 (Async)
```
[开始]
  ↓
[解析命令行参数]
  ↓
[初始化配置] → 加载.env → 初始化Logger
  ↓
[扫描图像目录] → 提取股票代码 → 验证文件
  ↓
[清空数据库表]
  ↓
[构建Async任务队列] ──┐
  ↓                  │
[并发调用LLM分析]     │ (asyncio.gather / Semaphore)
  ↓                  │
[解析返回结果]       │
  ↓                  │
[写入日志]           │
  ↓                ←─┘
[批量写入数据库]
  ↓
[输出统计报告]
  ↓
[结束]
```

---

## 5. 接口设计

### 5.1 命令行接口
```bash
python -m flatbottom_pipeline.refinement_llm.main
```
(参数同前文：`--image-dir`, `--model`, `--threshold`, `--batch-size`, `--debug`)

---

## 6. MS Agent-Framework 集成方案 (V2 修正版)

### 6.1 Agent与Client配置
基于 `agent-framework==1.0.0b260127`，使用 `ChatAgent` 配合 `OpenAIChatClient`。

```python
import asyncio
from agent_framework import ChatAgent
from agent_framework.openai import OpenAIChatClient

class AgentConfigurator:
    @staticmethod
    def create_client(model_name: str, api_key: str, base_url: str) -> OpenAIChatClient:
        """创建配置好的 Client 实例"""
        # 优先通过环境变量配置，此处仅作演示 explicit 传参
        # 注意：SDK 具体参数可能变化，建议优先使用 os.environ 配置 OPENAI_* 变量
        # 构造函数可能接受 model_id 或 model, 视具体 SDK 版本而定
        return OpenAIChatClient(
            model=model_name, # 或 model_id=model_name
            api_key=api_key,
            base_url=base_url
        )

    @staticmethod
    def create_agent(client: OpenAIChatClient, name: str) -> ChatAgent:
        """创建 ChatAgent 实例"""
        # 使用 ChatAgent 而不是 Agent
        return ChatAgent(
            name=name,
            chat_client=client, # 参数名是 chat_client
            instructions=SYSTEM_PROMPT,
            description="A specialized agent for technical analysis of stock charts."
        )
```

### 6.2 多模态输入处理 (Async + ChatMessage)
使用 `ChatMessage` 配合 `DataContent` (或 `ImageContent`) 发送图片。

```python
import base64
from agent_framework import ChatMessage, TextContent, DataContent

async def analyze_with_vision(agent: ChatAgent, image_path: str, stock_code: str) -> str:
    """使用多模态能力分析K线图 (Async)"""

    # 1. 读取图像并转为 Base64
    with open(image_path, "rb") as f:
        image_data = base64.b64encode(f.read()).decode()
    
    image_uri = f"data:image/png;base64,{image_data}"

    # 2. 构建多模态消息 (ChatMessage)
    # MAF 规范：使用 list of content items
    user_message = ChatMessage(
        role="user",
        content=[
            TextContent(text=get_user_prompt(stock_code)),
            DataContent(uri=image_uri, media_type="image/png") 
            # 或 ImageContent(uri=image_uri) 视具体类定义而定，DataContent 是通用的
        ]
    )

    # 3. 异步调用
    response_message = await agent.run(user_message)
    
    # 获取响应文本
    return response_message.text
```

---

## 7. 错误处理与容错设计

### 7.1 重试机制
- 使用 `tenacity` 库或自定义装饰器实现异步重试。
- 针对 `429 Too Many Requests` 和 `5xx` 错误进行指数退避。

### 7.2 降级策略
- 单个图像分析失败：记录 ERROR 日志，跳过该图像，不中断主流程。
- JSON解析失败：记录原始响应内容到日志，标记该条目失败。

---

## 8. 性能优化设计

### 8.1 并发控制 (Asyncio)
使用 `asyncio.Semaphore` 控制并发数量，防止触发 API限流。

```python
async def batch_analyze(self, images: List[StockImage], concurrency: int = 5):
    sem = asyncio.Semaphore(concurrency)
    
    async def _analyze_safe(img):
        async with sem:
            return await self.analyze_kline(img.file_path, img.stock_code)
            
    tasks = [_analyze_safe(img) for img in images]
    results = await asyncio.gather(*tasks)
    return results
```

---

## 9. 测试策略

### 9.1 单元测试
- 使用 `pytest-asyncio` 测试异步方法。
- Mock `ChatAgent` 的响应，避免真实消耗 Token。

---

## 10. 部署与运维

### 10.1 依赖安装
```bash
uv pip install "agent-framework==1.0.0b260127"
uv pip install psycopg2-binary pillow python-dotenv pydantic pytest-asyncio
```